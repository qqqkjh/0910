echo $PS1  /*프롬프트에대한 환경변수값
ls -l /bin/*sh  /*쓰는 쉘 표시
ps /* 현재 실행중인 모든 프로세스
sleep //~초동안 대기
kill //프로세스 죽이기
wait [프로세스번호] //해당번호 자식프로세스가 종료될떄까지 대기한다
exit [종료번호]// 쉘을 종료하고 종료코드 전달
atexit()//최대 32개까지 등록가능 종료시 하는 행동을 설정해두고 처리하는 exit 처리기 

후면처리 명령어
맨뒤에 & 붙이기
ex ) (sleep 10; echo done) &
-------------------------------------------------------------------------------------------------------------
발표주제

1. profile,bashrc // 시작파일 
    .bash_profile, .bashrc // 이후 실행
(각파일의 기능과 실제예에 대해 기술)

2 데몬 프로세스(종류)

3 문맥교환(context switching)에대해기술

4 static 에 대해 기술하시오 

5 init, systemd 

6 process 구조
-------------------------------------------------------------------------------------------------------------



1)date; who; pwd   각각 실행해서 출력
2)(date; who; pwd) 한번에 다가져와서 한번에 출력

 -------------------------------------------------------------------------------------------------------------
슬립시간재기+입력값 받아 슬립하기


#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/time.h>
int main(int argc, char *argv[]){
        struct timeval start,end;
        double gap;

        printf("hello\n");
        gettimeofday(&start,NULL);
        sleep(atoi(argv[1]));
        gettimeofday(&end,NULL);
        printf("bye\n");
        gap=end.tv_sec + end.tv_usec /1000000.0 - start.tv_sec - start.tv_usec /1000000.0;
        printf("%f\n",gap);
        return 0;
}
-------------------------------------------------------------------------------------------------------------

파인드함수 후면처리 (후면처리도 결과 알림 및 에러는 전면표시됨)
find/-name test.c &
-------------------------------------------------------------------------------------------------------------

c의 시작과정
exec 시스템호출
c시작 루틴에 명령줄인수와 환경변수 전달후 프로그램실행
    ㅣ
    C시작루틴
      main 함수를 호출하면서 명령줄 인수 ,환경변수 전달

       리턴문엔 이게 자동실행되며 생략되있다
        exit(main(argc,argv));

	실행이 끝나면 받환값을 받아 exit



-------------------------------------------------------------------------------------------------------------


printenv 출력

#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
    char    *ptr;
//각각의 환경변수를 출력한다 (env 환경변수)
    ptr = getenv("HOME");
    printf("HOME = %s \n", ptr);

    ptr = getenv("SHELL");
    printf("SHELL = %s \n", ptr);

    ptr = getenv("PATH");
    printf("PATH = %s \n", ptr);

    exit(0);
}

str = getenv("환경변수의 이름") 
        해당환경변수 출력

-------------------------------------------------------------------------------------------------------------

환경변수? - 프로세스가 컴퓨터에서 동작하는 방식에 영향을 미치는 동적인 값들의 모임 

Path 환경변수를 미리 설정을해두면 프롬프트(cmd등)상에서 Path 내에 저장된 모든 폴더,파일에 접근가능

ex) 1 프롬프트에 notepad 입력
     2 notepad가 명령어인지 파일명인지 인식
     3 Path 환경변수내 저장된 폴더에 존재하는지 검색
     4 해당 파일을 찾으면 경로를 지정(c:/windows/system32/notepad)하고 실행 
    
-------------------------------------------------------------------------------------------------------------

atexit() - exit 처리기의 예
// exit_handler1 는 따로 설정(행동을설정)해야됨 해당 함수는 핸들러를 등록하는작업 

#include <stdio.h>
//핸들러등록
  static void my_exit1(void),my_exit2(void);
 
 static void exit_handler1(void) {
     printf("첫 번째 exit 처리기\n");
 }
 static void exit_handler2(void) {
     printf("두 번째 exit 처리기\n");
 }
//메인문
  int main(void) {//밑의 if문을보면 atexit 에 선언한 핸들러를 등록함
  if (atexit(exit_handler1) != 0)	
     perror("exit_handler1 등록할 수 없음");
  if (atexit(exit_handler2) != 0) 	
     perror("exit_handler2 등록할 수 없음");
   printf("main 끝 \n");
 exit(0);
 }
//메인끝
-------------------------------------------------------------------------------------------------------------
프로세스 - 스택영역

-------------------------------------------------------------------------------------------------------------


init 프로세스
모든 프로세스는 위에서 처럼 PID를 가지고 또한 PPID 를 가진다. PID란 프로세스자신을 가리키는 일련의 번호이며 PPID란 자신을 실행시킨 부모프로세스의 PID를 가리킨다.
그렇다면 자신의 부모 프로세스를 실행시킨 프로세스가 존재할것이고, 또 그 부모 프로세스를 실행한 프로세스가 존재할것이다.

이런 식으로 유추해서 생각해 보면 결국 최초의 조상 프로세스가 존재할것이라는 결론에 도달할수 있을것인데(인류로 생각해보자면, "아담" 정도), 그것이 바로 PID 1번을 가지는 init 프로세스이다.
모든 프로세스는 init 로부터 fork & exec 과정을 거쳐서 독립된 프로세스로 임무를 수행하게 된다.

-------------------------------------------------------------------------------------------------------------
텍스트(text) 
프로세스가 실행하는 실행코드를 저장하는 영역이다.
데이터 (data)
전역 변수(global variable) 및 정적 변수(static variable)를 위한 메모리 영역이다. 
힙(heap) 
동적 메모리 할당을 위한 영역이다. C 언어의 malloc 함수를 호출하면 이 영역에서 동적으로 메모리를 할당해준다. 
스택(stack area)
함수 호출을 구현하기 위한 실행시간 스택(runtime stack)을 위한 영역으로 활성 레코드(activation record)가 저장된다. 
U-영역(user-area)
열린 파일 디스크립터, 현재 작업 디렉터리 등과 같은 프로세스의 정보를 저장하는 영역이다.
-------------------------------------------------------------------------------------------------------------
